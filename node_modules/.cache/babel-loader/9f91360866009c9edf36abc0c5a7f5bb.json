{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"C:\\\\Users\\\\youno\\\\tweetle\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\youno\\\\tweetle\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar conversions = require(\"webidl-conversions\");\n\nvar utils = require(\"./utils.js\");\n\nvar implSymbol = utils.implSymbol;\nvar ctorRegistrySymbol = utils.ctorRegistrySymbol;\nvar interfaceName = \"Location\";\n\nexports.is = function (value) {\n  return utils.isObject(value) && utils.hasOwn(value, implSymbol) && value[implSymbol] instanceof Impl.implementation;\n};\n\nexports.isImpl = function (value) {\n  return utils.isObject(value) && value instanceof Impl.implementation;\n};\n\nexports.convert = function (globalObject, value) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$context = _ref.context,\n      context = _ref$context === void 0 ? \"The provided value\" : _ref$context;\n\n  if (exports.is(value)) {\n    return utils.implForWrapper(value);\n  }\n\n  throw new globalObject.TypeError(\"\".concat(context, \" is not of type 'Location'.\"));\n};\n\nfunction makeWrapper(globalObject, newTarget) {\n  var proto;\n\n  if (newTarget !== undefined) {\n    proto = newTarget.prototype;\n  }\n\n  if (!utils.isObject(proto)) {\n    proto = globalObject[ctorRegistrySymbol][\"Location\"].prototype;\n  }\n\n  return Object.create(proto);\n}\n\nexports.create = function (globalObject, constructorArgs, privateData) {\n  var wrapper = makeWrapper(globalObject);\n  return exports.setup(wrapper, globalObject, constructorArgs, privateData);\n};\n\nexports.createImpl = function (globalObject, constructorArgs, privateData) {\n  var wrapper = exports.create(globalObject, constructorArgs, privateData);\n  return utils.implForWrapper(wrapper);\n};\n\nfunction getUnforgeables(globalObject) {\n  var unforgeables = unforgeablesMap.get(globalObject);\n\n  if (unforgeables === undefined) {\n    unforgeables = Object.create(null);\n    utils.define(unforgeables, {\n      assign: function assign(url) {\n        var _esValue$implSymbol;\n\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'assign' called on an object that is not a valid instance of Location.\");\n        }\n\n        if (arguments.length < 1) {\n          throw new globalObject.TypeError(\"Failed to execute 'assign' on 'Location': 1 argument required, but only \".concat(arguments.length, \" present.\"));\n        }\n\n        var args = [];\n        {\n          var curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'assign' on 'Location': parameter 1\",\n            globals: globalObject\n          });\n          args.push(curArg);\n        }\n        return (_esValue$implSymbol = esValue[implSymbol]).assign.apply(_esValue$implSymbol, args);\n      },\n      replace: function replace(url) {\n        var _esValue$implSymbol2;\n\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'replace' called on an object that is not a valid instance of Location.\");\n        }\n\n        if (arguments.length < 1) {\n          throw new globalObject.TypeError(\"Failed to execute 'replace' on 'Location': 1 argument required, but only \".concat(arguments.length, \" present.\"));\n        }\n\n        var args = [];\n        {\n          var curArg = arguments[0];\n          curArg = conversions[\"USVString\"](curArg, {\n            context: \"Failed to execute 'replace' on 'Location': parameter 1\",\n            globals: globalObject\n          });\n          args.push(curArg);\n        }\n        return (_esValue$implSymbol2 = esValue[implSymbol]).replace.apply(_esValue$implSymbol2, args);\n      },\n      reload: function reload() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'reload' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol].reload();\n      },\n\n      get href() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get href' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"href\"];\n      },\n\n      set href(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set href' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'href' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"href\"] = V;\n      },\n\n      toString: function toString() {\n        var esValue = this;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'toString' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"href\"];\n      },\n\n      get origin() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get origin' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"origin\"];\n      },\n\n      get protocol() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get protocol' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"protocol\"];\n      },\n\n      set protocol(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set protocol' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'protocol' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"protocol\"] = V;\n      },\n\n      get host() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get host' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"host\"];\n      },\n\n      set host(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set host' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'host' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"host\"] = V;\n      },\n\n      get hostname() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get hostname' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"hostname\"];\n      },\n\n      set hostname(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set hostname' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'hostname' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"hostname\"] = V;\n      },\n\n      get port() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get port' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"port\"];\n      },\n\n      set port(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set port' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'port' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"port\"] = V;\n      },\n\n      get pathname() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get pathname' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"pathname\"];\n      },\n\n      set pathname(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set pathname' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'pathname' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"pathname\"] = V;\n      },\n\n      get search() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get search' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"search\"];\n      },\n\n      set search(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set search' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'search' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"search\"] = V;\n      },\n\n      get hash() {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'get hash' called on an object that is not a valid instance of Location.\");\n        }\n\n        return esValue[implSymbol][\"hash\"];\n      },\n\n      set hash(V) {\n        var esValue = this !== null && this !== undefined ? this : globalObject;\n\n        if (!exports.is(esValue)) {\n          throw new globalObject.TypeError(\"'set hash' called on an object that is not a valid instance of Location.\");\n        }\n\n        V = conversions[\"USVString\"](V, {\n          context: \"Failed to set the 'hash' property on 'Location': The provided value\",\n          globals: globalObject\n        });\n        esValue[implSymbol][\"hash\"] = V;\n      }\n\n    });\n    Object.defineProperties(unforgeables, {\n      assign: {\n        configurable: false,\n        writable: false\n      },\n      replace: {\n        configurable: false,\n        writable: false\n      },\n      reload: {\n        configurable: false,\n        writable: false\n      },\n      href: {\n        configurable: false\n      },\n      toString: {\n        configurable: false,\n        writable: false\n      },\n      origin: {\n        configurable: false\n      },\n      protocol: {\n        configurable: false\n      },\n      host: {\n        configurable: false\n      },\n      hostname: {\n        configurable: false\n      },\n      port: {\n        configurable: false\n      },\n      pathname: {\n        configurable: false\n      },\n      search: {\n        configurable: false\n      },\n      hash: {\n        configurable: false\n      }\n    });\n    unforgeablesMap.set(globalObject, unforgeables);\n  }\n\n  return unforgeables;\n}\n\nexports._internalSetup = function (wrapper, globalObject) {\n  utils.define(wrapper, getUnforgeables(globalObject));\n};\n\nexports.setup = function (wrapper, globalObject) {\n  var constructorArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var privateData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  privateData.wrapper = wrapper;\n\n  exports._internalSetup(wrapper, globalObject);\n\n  Object.defineProperty(wrapper, implSymbol, {\n    value: new Impl.implementation(globalObject, constructorArgs, privateData),\n    configurable: true\n  });\n  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;\n\n  if (Impl.init) {\n    Impl.init(wrapper[implSymbol]);\n  }\n\n  return wrapper;\n};\n\nexports.new = function (globalObject, newTarget) {\n  var wrapper = makeWrapper(globalObject, newTarget);\n\n  exports._internalSetup(wrapper, globalObject);\n\n  Object.defineProperty(wrapper, implSymbol, {\n    value: Object.create(Impl.implementation.prototype),\n    configurable: true\n  });\n  wrapper[implSymbol][utils.wrapperSymbol] = wrapper;\n\n  if (Impl.init) {\n    Impl.init(wrapper[implSymbol]);\n  }\n\n  return wrapper[implSymbol];\n};\n\nvar unforgeablesMap = new WeakMap();\nvar exposed = new Set([\"Window\"]);\n\nexports.install = function (globalObject, globalNames) {\n  if (!globalNames.some(function (globalName) {\n    return exposed.has(globalName);\n  })) {\n    return;\n  }\n\n  var ctorRegistry = utils.initCtorRegistry(globalObject);\n\n  var Location = function Location() {\n    _classCallCheck(this, Location);\n\n    throw new globalObject.TypeError(\"Illegal constructor\");\n  };\n\n  Object.defineProperties(Location.prototype, _defineProperty({}, Symbol.toStringTag, {\n    value: \"Location\",\n    configurable: true\n  }));\n  ctorRegistry[interfaceName] = Location;\n  Object.defineProperty(globalObject, interfaceName, {\n    configurable: true,\n    writable: true,\n    value: Location\n  });\n};\n\nvar Impl = require(\"../window/Location-impl.js\");","map":null,"metadata":{},"sourceType":"script"}